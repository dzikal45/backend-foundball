{"version":3,"file":"error.spec.js","sourceRoot":"","sources":["../../../src/__tests__/utc-time/error.spec.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,OAAO,EAAE,MAAM,yBAAyB,CAAC;AAElD,IAAI,CAAC,yBAAyB,EAAE,KAAK,IAAI,EAAE;IACzC,IAAI;QACF,MAAM,OAAO,CAAC,EAAE,aAAa,EAAE,cAAc,EAAE,CAAC,CAAC;KAClD;IAAC,OAAO,CAAC,EAAE;QAEV,MAAM,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,IAAI,SAAS,CAAC,8EAA8E,CAAC,CAAC,CAAC;KACxH;AACH,CAAC,CAAC,CAAC;AAEH,IAAI,CAAC,+BAA+B,EAAE,KAAK,IAAI,EAAE;IAC/C,IAAI;QACF,MAAM,OAAO,CAAC,EAAE,MAAM,EAAE,EAAE,IAAI,EAAE,GAAG,EAAE,EAAE,CAAC,CAAC;KAC1C;IAAC,OAAO,CAAC,EAAE;QAEV,MAAM,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,IAAI,SAAS,CAAC,2DAA2D,CAAC,CAAC,CAAC;KACrG;AACH,CAAC,CAAC,CAAC;AAEH,IAAI,CAAC,iCAAiC,EAAE,KAAK,IAAI,EAAE;IACjD,IAAI;QACF,MAAM,OAAO,CAAC,EAAE,MAAM,EAAE,EAAE,MAAM,EAAE,GAAG,EAAE,EAAE,CAAC,CAAC;KAC5C;IAAC,OAAO,CAAC,EAAE;QAEV,MAAM,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,IAAI,SAAS,CAAC,6DAA6D,CAAC,CAAC,CAAC;KACvG;AACH,CAAC,CAAC,CAAC;AAEH,IAAI,CAAC,iCAAiC,EAAE,KAAK,IAAI,EAAE;IACjD,IAAI;QACF,MAAM,OAAO,CAAC,EAAE,MAAM,EAAE,EAAE,MAAM,EAAE,GAAG,EAAE,EAAE,CAAC,CAAC;KAC5C;IAAC,OAAO,CAAC,EAAE;QAEV,MAAM,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,IAAI,SAAS,CAAC,6DAA6D,CAAC,CAAC,CAAC;KACvG;AACH,CAAC,CAAC,CAAC;AAEH,IAAI,CAAC,sCAAsC,EAAE,KAAK,IAAI,EAAE;IACtD,IAAI;QACF,MAAM,OAAO,CAAC,EAAE,MAAM,EAAE,EAAE,WAAW,EAAE,GAAG,EAAE,EAAE,CAAC,CAAC;KACjD;IAAC,OAAO,CAAC,EAAE;QAEV,MAAM,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,IAAI,SAAS,CAAC,kEAAkE,CAAC,CAAC,CAAC;KAC5G;AACH,CAAC,CAAC,CAAC","sourcesContent":["import { utcTime } from '../../utc-time/index.js';\n\ntest(`invalid 'startDatetime'`, async () => {\n  try {\n    await utcTime({ startDatetime: 'invalid-date' });\n  } catch (e) {\n    // tslint:disable-next-line: max-line-length\n    expect(e).toStrictEqual(new TypeError(`Expected 'startDatetime' to be a valid datetime, but received 'invalid-date'`));\n  }\n});\n\ntest(`'offset.hour' is not a number`, async () => {\n  try {\n    await utcTime({ offset: { hour: NaN } });\n  } catch (e) {\n    // tslint:disable-next-line: max-line-length\n    expect(e).toStrictEqual(new TypeError(`Expected 'offset.hour' to be a number, but received 'NaN'`));\n  }\n});\n\ntest(`'offset.minute' is not a number`, async () => {\n  try {\n    await utcTime({ offset: { minute: NaN } });\n  } catch (e) {\n    // tslint:disable-next-line: max-line-length\n    expect(e).toStrictEqual(new TypeError(`Expected 'offset.minute' to be a number, but received 'NaN'`));\n  }\n});\n\ntest(`'offset.second' is not a number`, async () => {\n  try {\n    await utcTime({ offset: { second: NaN } });\n  } catch (e) {\n    // tslint:disable-next-line: max-line-length\n    expect(e).toStrictEqual(new TypeError(`Expected 'offset.second' to be a number, but received 'NaN'`));\n  }\n});\n\ntest(`'offset.millisecond' is not a number`, async () => {\n  try {\n    await utcTime({ offset: { millisecond: NaN } });\n  } catch (e) {\n    // tslint:disable-next-line: max-line-length\n    expect(e).toStrictEqual(new TypeError(`Expected 'offset.millisecond' to be a number, but received 'NaN'`));\n  }\n});\n"]}