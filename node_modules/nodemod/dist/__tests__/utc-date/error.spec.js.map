{"version":3,"file":"error.spec.js","sourceRoot":"","sources":["../../../src/__tests__/utc-date/error.spec.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,OAAO,EAAE,MAAM,yBAAyB,CAAC;AAElD,EAAE,CAAC,sCAAsC,EAAE,KAAK,IAAI,EAAE;IACpD,IAAI;QACF,MAAM,OAAO,CAAC,IAAa,CAAC,CAAC;KAC9B;IAAC,OAAO,CAAC,EAAE;QACV,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,aAAa,CAAC,WAAW,CAAC,CAAC;QAC1C,MAAM,CAAC;YACL,qEAAqE;YACrE,0HAA0H;SAC3H,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,OAAO,KAAK,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;KACnD;AACH,CAAC,CAAC,CAAC;AAEH,EAAE,CAAC,4BAA4B,EAAE,KAAK,IAAI,EAAE;IAC1C,IAAI;QACF,MAAM,OAAO,CAAC,EAAE,MAAM,EAAE,EAAE,IAAI,EAAE,GAAG,EAAE,EAAE,CAAC,CAAC;KAC1C;IAAC,OAAO,CAAC,EAAE;QACV,MAAM,CAAC,CAAC,CAAC,CAAC,aAAa,CACrB,IAAI,SAAS,CAAC,uDAAuD,GAAG,GAAG,CAAC,CAAC,CAAC;KACjF;AACH,CAAC,CAAC,CAAC;AAEH,EAAE,CAAC,6BAA6B,EAAE,KAAK,IAAI,EAAE;IAC3C,IAAI;QACF,MAAM,OAAO,CAAC,EAAE,MAAM,EAAE,EAAE,KAAK,EAAE,GAAG,EAAE,EAAE,CAAC,CAAC;KAC3C;IAAC,OAAO,CAAC,EAAE;QACV,MAAM,CAAC,CAAC,CAAC,CAAC,aAAa,CACrB,IAAI,SAAS,CAAC,wDAAwD,GAAG,GAAG,CAAC,CAAC,CAAC;KAClF;AACH,CAAC,CAAC,CAAC;AAEH,EAAE,CAAC,2BAA2B,EAAE,KAAK,IAAI,EAAE;IACzC,IAAI;QACF,MAAM,OAAO,CAAC,EAAE,MAAM,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,CAAC,CAAC;KACzC;IAAC,OAAO,CAAC,EAAE;QACV,MAAM,CAAC,CAAC,CAAC,CAAC,aAAa,CACrB,IAAI,SAAS,CAAC,sDAAsD,GAAG,GAAG,CAAC,CAAC,CAAC;KAChF;AACH,CAAC,CAAC,CAAC","sourcesContent":["import { utcDate } from '../../utc-date/index.js';\n\nit(`throws when first argument is 'null'`, async () => {\n  try {\n    await utcDate(null as never);\n  } catch (e) {\n    expect(e.name).toStrictEqual('TypeError');\n    expect([\n      `Cannot destructure property \\`startDate\\` of 'undefined' or 'null'.`,\n      `Cannot destructure property 'startDate' of '(intermediate value)(intermediate value)(intermediate value)' as it is null.`,\n    ].some(n => e.message === n)).toStrictEqual(true);\n  }\n});\n\nit(`throws when invalid 'year'`, async () => {\n  try {\n    await utcDate({ offset: { year: NaN } });\n  } catch (e) {\n    expect(e).toStrictEqual(\n      new TypeError(`Expected 'year' to be a valid number, but received '${NaN}'`));\n  }\n});\n\nit(`throws when invalid 'month'`, async () => {\n  try {\n    await utcDate({ offset: { month: NaN } });\n  } catch (e) {\n    expect(e).toStrictEqual(\n      new TypeError(`Expected 'month' to be a valid number, but received '${NaN}'`));\n  }\n});\n\nit(`throws when invalid 'day'`, async () => {\n  try {\n    await utcDate({ offset: { day: NaN } });\n  } catch (e) {\n    expect(e).toStrictEqual(\n      new TypeError(`Expected 'day' to be a valid number, but received '${NaN}'`));\n  }\n});\n"]}